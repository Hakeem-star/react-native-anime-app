import React, { useEffect, useMemo, useState } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableHighlight,
  FlatList,
} from "react-native";
import styled from "styled-components/native";
import Header from "../components/Header";
import Page from "../components/Page";

import SearchResults from "../components/SearchResults";
import { createStackNavigator } from "@react-navigation/stack";
import {
  AnimeMediaFragment,
  AnimesDocument,
  CoverImageFragment,
  fetcher,
  Maybe,
  useAnimesQuery,
} from "../generated/graphql";
import { ANILIST_ENDPOINT } from "../constants/queryConfigs";
import debounce from "lodash.debounce";
import { useInfiniteGraphQLQuery } from "../util/useInfiniteGraphQLQuery";
import { useQueryClient } from "react-query";
import { ResultTabs } from "../navigation/ResultTabs";
import { RootStackProps } from "../App";
import AnimeResult from "../components/TwoDimension/AnimeResult";
const Stack = createStackNavigator();

const StyledInput = styled(TextInput)`
  height: 50px;
  padding: 0 15px;
  border-radius: 3px;
  border: 1px solid #9fa5aa;
`;

interface Props {}

const TwoDimensionHome = ({ navigation, route }: RootStackProps) => {
  const [text, setText] = useState("");

  const queryClient = useQueryClient();

  const { fetchNextPage, hasNextPage, data, isLoading, refetch } =
    useInfiniteGraphQLQuery(
      useAnimesQuery, // this is a hook generated by typescript-react-query
      ({ pageParam = 1 }) => ({
        page: pageParam,
        name: text,
      }),
      {
        enabled: false,
        initialData: { pages: [], pageParams: [] },
        getNextPageParam: (lastPage, pages) => {
          const result = lastPage?.Page?.pageInfo?.hasNextPage
            ? lastPage?.Page?.pageInfo?.currentPage
              ? lastPage?.Page?.pageInfo?.currentPage + 1
              : lastPage?.Page?.pageInfo?.currentPage
            : undefined;

          return result;
        },
      }
    );

  const debouncedRefetch = useMemo(
    () =>
      debounce(() => {
        queryClient.resetQueries("animes", { exact: true });

        refetch();
      }, 20),
    [refetch]
  );

  useEffect(() => {
    if (text) {
      debouncedRefetch();
    }
  }, [text]);

  const result = data?.pages?.reduce((acc, current) => {
    return [
      ...acc,
      ...(current.Page?.media?.filter((media) => {
        return (
          !!media &&
          (media?.title?.romaji?.toLowerCase()?.includes(text.toLowerCase()) ||
            media?.title?.english?.toLowerCase()?.includes(text.toLowerCase()))
        );
      }) || []),
    ];
  }, [] as ((AnimeMediaFragment & CoverImageFragment) | null)[]);
  console.log({ result });

  return (
    <Page>
      <View
        style={{
          marginTop: 15,
          maxHeight: "100%",
          height: "100%",
          overflow: "hidden",
        }}
      >
        {!!route?.params?.showSearchBar && (
          <View style={{ paddingHorizontal: 20 }}>
            <StyledInput
              autoFocus
              onChangeText={(text: string) => {
                setText(text);
              }}
              value={text}
              placeholder={"Search for Anime"}
              placeholderTextColor={"#ADB2B6"}
            />
          </View>
        )}

        <FlatList
          contentContainerStyle={{
            display: "flex",
            alignItems: "center",
            padding: 20,
          }}
          data={result}
          renderItem={(item) => <AnimeResult anime={item.item} />}
          numColumns={2}
          horizontal={false}
        />
      </View>
    </Page>
  );
};

export default TwoDimensionHome;
