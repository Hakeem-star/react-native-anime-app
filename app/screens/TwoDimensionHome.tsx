import React, { useEffect, useMemo, useState } from "react";
import { View, Text, FlatList } from "react-native";
import styled from "styled-components/native";
import Page from "../components/Page";

import {
  AnimeMediaFragment,
  CoverImageFragment,
  useAnimesQuery,
} from "../generated/graphql";
import debounce from "lodash.debounce";
import { useInfiniteGraphQLQuery } from "../util/useInfiniteGraphQLQuery";
import { useQueryClient } from "react-query";
import { RootStackProps } from "../App";
import AnimeResult from "../components/TwoDimension/AnimeResult";
import { Gyroscope, ThreeAxisMeasurement } from "expo-sensors";
import SearchInput from "./SearchInput";

const EmptyState = styled(View)`
  margin-top: 50px;
`;

interface Props {}

const TwoDimensionHome = ({ navigation, route }: RootStackProps) => {
  const [text, setText] = useState("");
  const [offsetY, setOffsetY] = useState(0);
  const [subscription, setSubscription] = useState<ReturnType<
    typeof Gyroscope.addListener
  > | null>(null);
  const [gyroData, setGyroData] = useState<ThreeAxisMeasurement>({
    x: 0,
    y: 0,
    z: 0,
  });

  const queryClient = useQueryClient();

  const _subscribe = () => {
    setSubscription(
      Gyroscope.addListener((gyroscopeData) => {
        const data = { ...gyroscopeData };
        if (data.y < 0.01 && data.y > -0.01) {
          setGyroData({ ...gyroscopeData, y: 0 });
        } else setGyroData(gyroscopeData);
      })
    );
  };

  const _unsubscribe = () => {
    subscription && subscription.remove();
    setSubscription(null);
  };

  useEffect(() => {
    Gyroscope.setUpdateInterval(300);
    // TODO - This is causing slowdown when there are a lot of results
    // _subscribe();
    return () => _unsubscribe();
  }, [setGyroData]);

  const { fetchNextPage, hasNextPage, data, isLoading, refetch } =
    useInfiniteGraphQLQuery(
      useAnimesQuery, // this is a hook generated by typescript-react-query
      ({ pageParam = 1 }) => ({
        page: pageParam,
        name: text.trim(),
      }),
      {
        enabled: false,
        initialData: { pages: [], pageParams: [] },
        getNextPageParam: (lastPage, pages) => {
          const result = lastPage?.Page?.pageInfo?.hasNextPage
            ? lastPage?.Page?.pageInfo?.currentPage
              ? lastPage?.Page?.pageInfo?.currentPage + 1
              : lastPage?.Page?.pageInfo?.currentPage
            : undefined;

          return result;
        },
      }
    );

  const debouncedRefetch = useMemo(
    () =>
      debounce(() => {
        queryClient.resetQueries("animes", { exact: true });

        refetch();
      }, 20),
    [refetch]
  );

  useEffect(() => {
    if (text) {
      debouncedRefetch();
    }
  }, [text]);

  const result = useMemo(
    () =>
      data?.pages?.reduce((acc, current) => {
        return [
          ...acc,
          ...(current.Page?.media?.filter((media) => {
            return (
              !!media &&
              (media?.title?.romaji
                ?.toLowerCase()
                ?.includes(text.trim().toLowerCase()) ||
                media?.title?.english
                  ?.toLowerCase()
                  ?.includes(text.trim().toLowerCase()))
            );
          }) || []),
        ];
      }, [] as ((AnimeMediaFragment & CoverImageFragment) | null)[]),
    [data]
  );

  return (
    <Page>
      <View
        style={{
          marginTop: 15,
          maxHeight: "100%",
          height: "100%",
          overflow: "hidden",
          display: "flex",
          alignItems: "center",
        }}
      >
        {!!route?.params?.showSearchBar && (
          <SearchInput
            defaultText={text}
            onChange={(value) => {
              setText(value);
            }}
            placeholder={"Search for Anime"}
          />
        )}
        {result?.length ? (
          <FlatList
            onEndReached={() => {
              queryClient.resetQueries("animes", { exact: true });

              fetchNextPage();
            }}
            style={{ marginTop: 20 }}
            contentContainerStyle={{
              display: "flex",
              alignItems: "flex-start",
              paddingBottom: 50,
            }}
            data={result}
            renderItem={(item) => {
              return item.item ? (
                <AnimeResult anime={item.item} rotation={gyroData} />
              ) : null;
            }}
            numColumns={2}
            horizontal={false}
          />
        ) : // We should only be showing this if we have stopped typing for a while
        text ? (
          <EmptyState>
            <Text>Nothing found</Text>
          </EmptyState>
        ) : null}
      </View>
    </Page>
  );
};

export default TwoDimensionHome;
